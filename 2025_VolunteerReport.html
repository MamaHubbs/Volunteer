<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volunteer Requirement Report</title>
    <style>
        /* General Body and Heading Styles */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f4f7f6; color: #333; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 15px; }
        p { color: #555; line-height: 1.5; }

        /* Loading and Error Messages */
        .loading-message { color: #3498db; font-style: italic; text-align: center; padding: 20px; }
        .error-message { color: #e74c3c; font-weight: bold; text-align: center; padding: 20px; border: 1px solid #e74c3c; background-color: #ffe6e6; }

        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #e0e0e0;
            padding: 12px 15px;
            text-align: left;
            vertical-align: middle;
        }
        th {
            background-color: #34495e;
            color: #ecf0f1;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #2c3e50;
        }
        tr:nth-child(even) { background-color: #fdfdfd; }
        tr:nth-child(odd) { background-color: #ffffff; }
        tbody tr:hover { background-color: #eaf6ff; }

        /* Conditional Styling for Competed / Met Requirement */
        .competed-yes { background-color: #d4edda; }
        .competed-no { background-color: #f8d7da; }
        .met-yes { font-weight: bold; color: #28a745; }
        .met-no { font-weight: bold; color: #dc3545; }
        .met-na { color: #6c757d; font-style: italic; }

        /* Sort Arrows */
        .sort-arrow {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 8px;
            vertical-align: middle;
        }
        .sort-arrow.asc {
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid #ecf0f1;
        }
        .sort-arrow.desc {
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid #ecf0f1;
        }

        /* Filter Section Styling */
        .filter-section {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-section label {
            font-weight: bold;
            color: #34495e;
        }
        .filter-section select { /* Styling for select dropdown */
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
            flex-grow: 1;
            max-width: 300px;
            background-color: white;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Volunteer Requirement Report</h1>
    <p>This report helps compare swimmers who competed in a meet with parents who volunteered. <br>
       <strong>Rule:</strong> If a family had a swimmer competing in a meet, a parent should have volunteered for that meet.</p>

    <div class="filter-section">
        <label for="parentNameFilterSelect">Filter by Parent Name:</label>
        <select id="parentNameFilterSelect">
            <option value="">All Parents</option>
        </select>
    </div>

    <div id="report-container" class="loading-message">Loading report data...</div>

    <script>
        const PARENT_DATA_URL = 'https://raw.githubusercontent.com/MamaHubbs/Volunteer/refs/heads/main/2025_volunteerdata.json';
        const SWIMMER_DATA_URL = 'https://raw.githubusercontent.com/MamaHubbs/Volunteer/refs/heads/main/2025_swimmerdata.json'; // IMPORTANT: CHECK REPO NAME HERE

        let allReportRows = []; // Store the processed data globally
        let currentSortKey = "Meet Date"; // Default sort column
        let currentSortDirection = "asc"; // Default sort direction
        let currentFilterParentName = ""; // Stores the selected parent name from dropdown

        // Helper function to convert Dataclip JSON format to array of objects
        function parseDataclipJson(data) {
            if (!data || !Array.isArray(data.fields) || !Array.isArray(data.values)) {
                console.warn("Provided data does not match expected Dataclip JSON format:", data);
                return [];
            }
            const fields = data.fields;
            const values = data.values;
            return values.map(row => {
                const obj = {};
                fields.forEach((field, index) => {
                    obj[field] = row[index];
                });
                return obj;
            });
        }

        async function loadJsonData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} for ${url}`);
                }
                const rawData = await response.json();
                return parseDataclipJson(rawData);
            } catch (error) {
                console.error(`Error loading or parsing data from ${url}:`, error);
                const container = document.getElementById('report-container');
                container.innerHTML = `<p class="error-message">Failed to load data from ${url}. Please check the URL, network, or JSON format. Error: ${error.message}</p>`;
                throw error;
            }
        }

        function renderTableBody(dataRows) {
            const tbody = document.querySelector('#report-container tbody');
            if (!tbody) return;

            tbody.innerHTML = ''; // Clear existing rows

            if (dataRows.length === 0) {
                tbody.insertAdjacentHTML('beforeend', `<tr><td colspan="9" style="text-align: center; color: #6c757d;">No results found for current filters.</td></tr>`);
                return;
            }

            dataRows.forEach(rowData => {
                const competedClass = rowData["Competed YES/NO"] === "YES" ? "competed-yes" : "competed-no";
                const metClass = rowData["Met Requirement"] === "YES" ? "met-yes" :
                                 (rowData["Met Requirement"].startsWith("NO") ? "met-no" : "met-na");

                const rowHtml = `
                    <tr class="${competedClass}">
                        <td>${rowData["Meet Date"] || "N/A"}</td>
                        <td>${rowData["Meet Name"] || "N/A"}</td>
                        <td>${rowData["Swimmer Name"] || "N/A"}</td>
                        <td>${rowData["Competed YES/NO"] || "N/A"}</td>
                        <td>${rowData["Parent Name"] || "N/A"}</td>
                        <td>${rowData["Job"] || "N/A"}</td>
                        <td>${rowData["Shift"] || "N/A"}</td>
                        <td>${rowData["Points"] || "N/A"}</td>
                        <td class="${metClass}">${rowData["Met Requirement"] || "N/A"}</td>
                    </tr>
                `;
                tbody.insertAdjacentHTML('beforeend', rowHtml);
            });
        }

        function applyFiltersAndSort() {
            let filteredRows = allReportRows;

            // Apply filter if a parent name is selected (value is not empty)
            if (currentFilterParentName && currentFilterParentName !== "") {
                filteredRows = allReportRows.filter(row => {
                    return row["Parent Name"] === currentFilterParentName;
                });
            }

            // Apply sort
            filteredRows.sort((a, b) => {
                const valA = a[currentSortKey];
                const valB = b[currentSortKey];

                let comparison = 0;

                // Specific sorting logic based on column key
                if (currentSortKey === "Meet Date") {
                    comparison = new Date(valA) - new Date(valB);
                } else if (currentSortKey === "Points") {
                    comparison = (parseFloat(valA) || 0) - (parseFloat(valB) || 0); // Convert to number, default to 0 if N/A
                } else if (currentSortKey === "Competed YES/NO" || currentSortKey === "Met Requirement") {
                    // Custom sort order for these status columns
                    const order = {
                        "YES": 1,
                        "N/A (No Child Competed)": 2,
                        "NO (Child Competed, Parent Not Volunteered)": 3,
                        "N/A": 4 // For parent volunteer rows without child competed (e.g. general 'N/A' for Swimmer Name)
                    };
                    comparison = (order[valA] || 99) - (order[valB] || 99); // Use a high number for unknown states to push them to end
                } else {
                    // Default string comparison for other text columns
                    comparison = String(valA).localeCompare(String(valB));
                }

                return currentSortDirection === "asc" ? comparison : -comparison; // Apply ascending or descending direction
            });

            renderTableBody(filteredRows); // Render the table with the filtered and sorted data
        }

        function initSorting() {
            // Attach click listeners to all sortable table headers
            document.querySelectorAll('th[data-sort-key]').forEach(header => {
                header.addEventListener('click', () => {
                    const key = header.getAttribute('data-sort-key');
                    // If the same header is clicked, toggle sort direction
                    if (currentSortKey === key) {
                        currentSortDirection = (currentSortDirection === "asc") ? "desc" : "asc";
                    } else {
                        // If a new header is clicked, set it as the new sort key and reset to ascending
                        currentSortKey = key;
                        currentSortDirection = "asc";
                    }

                    // Remove existing sort arrows from all headers
                    document.querySelectorAll('th[data-sort-key] .sort-arrow').forEach(arrow => arrow.classList.remove('asc', 'desc'));
                    // Add the correct arrow class to the currently sorted header
                    const currentArrow = document.querySelector(`th[data-sort-key="${currentSortKey}"] .sort-arrow`);
                    if (currentArrow) {
                        currentArrow.classList.add(currentSortDirection);
                    }

                    applyFiltersAndSort(); // Re-apply filters and sort (will re-render the table)
                });
                // Add the sort arrow span to each header if it doesn't exist
                if (!header.querySelector('.sort-arrow')) {
                    header.insertAdjacentHTML('beforeend', '<span class="sort-arrow"></span>');
                }
            });
            // Initial sort applied in generateReport via applyFiltersAndSort
        }

        // Function to populate the dropdown with unique parent names
        function populateParentFilterDropdown(parentVolunteersData) {
            const selectElement = document.getElementById('parentNameFilterSelect');
            const uniqueParents = new Set(); // Use a Set to automatically handle duplicates

            // Iterate through the raw parent volunteer data to extract unique parent names
            parentVolunteersData.forEach(row => {
                // Ensure the 'Parent' field exists and is not our 'N/A' placeholder from non-volunteers
                if (row.Parent && row.Parent !== "N/A (No Volunteer)") {
                    uniqueParents.add(row.Parent);
                }
            });

            // Convert the Set to an Array and sort alphabetically
            const sortedParents = Array.from(uniqueParents).sort();

            // Add the default "All Parents" option first
            selectElement.innerHTML = '<option value="">All Parents</option>';

            // Add each unique parent name as an option in the dropdown
            sortedParents.forEach(parentName => {
                const option = document.createElement('option');
                option.value = parentName;      // The value sent when selected
                option.textContent = parentName; // The text displayed in the dropdown
                selectElement.appendChild(option);
            });

            // Add event listener to the dropdown for when its value changes
            selectElement.addEventListener('change', (event) => {
                currentFilterParentName = event.target.value; // Update the filter variable
                applyFiltersAndSort(); // Re-apply filters and sort to update the table
            });
        }


        // Main function to generate the report when the page loads
        async function generateReport() {
            const container = document.getElementById('report-container');
            container.innerHTML = '<p class="loading-message">Processing data...</p>';

            let swimmersCompeting = [];
            let parentVolunteers = [];

            try {
                // Load and parse both JSON data sources
                swimmersCompeting = await loadJsonData(SWIMMER_DATA_URL);
                parentVolunteers = await loadJsonData(PARENT_DATA_URL);
            } catch (error) {
                // Error handling is inside loadJsonData, so just return if an error occurred
                return;
            }

            // Check if both datasets are empty after loading
            if (!swimmersCompeting.length && !parentVolunteers.length) {
                container.innerHTML = "<p>No data loaded to generate report.</p>";
                return;
            }

            // --- Step 1: Create a lookup for swimmers who competed in each meet ---
            // This lookup helps determine the "Competed YES/NO" status efficiently
            const competedSwimmersByMeet = {}; // Structure: {'Meet Name': {'YYYY-MM-DD': Set('Swimmer Name')}}
            swimmersCompeting.forEach(row => {
                const meetName = row["Meet Name"];
                const meetDate = row["Meet Date"];
                const swimmerName = row["Swimmer Name"];
                const countResults = row["Count of Events With Results"] || 0; // Default to 0 if null/undefined

                // Only consider swimmers who actually had results for a meet
                if (meetName && meetDate && swimmerName && countResults > 0) {
                    if (!(meetName in competedSwimmersByMeet)) {
                        competedSwimmersByMeet[meetName] = {};
                    }
                    if (!(meetDate in competedSwimmersByMeet[meetName])) {
                        competedSwimmersByMeet[meetName][meetDate] = new Set();
                    }
                    competedSwimmersByMeet[meetName][meetDate].add(swimmerName);
                }
            });

            // --- Step 2: Process Parent Volunteer Data to build initial report rows ---
            const tempReportRows = []; // Temporary array to build all rows
            const processedParentJobCombos = new Set(); // Tracks unique parent job assignments to avoid duplication
            const processedSwimmerMeetCombos = new Set(); // Tracks which swimmers have been "covered" by a volunteering parent for a specific meet

            parentVolunteers.forEach(parentRow => {
                const meetDate = parentRow["Meet Date"];
                const meetName = parentRow["Meet Name"];
                const parentName = parentRow.Parent;
                const job = parentRow.Job;
                const shift = parentRow.Shift;
                const points = parentRow.Points;

                // Create a unique identifier for this specific parent's job/shift entry
                // This helps avoid adding the same job assignment multiple times if data has duplicates
                const parentJobId = `${meetDate}|${meetName}|${parentName}|${job}|${shift}|${points}`;
                if (processedParentJobCombos.has(parentJobId)) {
                    return; // Skip if this exact job assignment for this parent has already been processed
                }
                processedParentJobCombos.add(parentJobId);

                // Collect all associated swimmers for this parent from the 'Swimmer X' columns
                const associatedSwimmersList = [];
                for (let i = 1; i <= 9; i++) { // Loop from Swimmer 1 to Swimmer 9
                    const swimmerCol = parentRow[`Swimmer ${i}`]; // Access column using bracket notation due to space
                    if (swimmerCol) { // If the column has a value (i.e., not null/empty)
                        associatedSwimmersList.push(swimmerCol);
                    }
                }

                let competedStatus = "NO"; // Default to NO
                // Check if ANY of this parent's associated swimmers competed in THIS meet
                for (const swimmer of associatedSwimmersList) {
                    if (meetName in competedSwimmersByMeet &&
                        meetDate in competedSwimmersByMeet[meetName] &&
                        competedSwimmersByMeet[meetName][meetDate].has(swimmer)) {
                        competedStatus = "YES"; // Set to YES if any child competed
                        // Mark this specific swimmer-meet combination as having a parent volunteer
                        processedSwimmerMeetCombos.add(`${meetDate}|${meetName}|${swimmer}`);
                    }
                }

                // Determine the "Met Requirement" status based on the business rule
                let metRequirement;
                if (competedStatus === "YES") {
                    metRequirement = "YES"; // Child competed AND parent volunteered for this meet
                } else {
                    metRequirement = "N/A (No Child Competed)"; // Parent volunteered, but none of their children competed in this meet
                }

                // Add this row to our temporary report data
                tempReportRows.push({
                    "Meet Date": meetDate,
                    "Meet Name": meetName,
                    "Swimmer Name": associatedSwimmersList.length ? associatedSwimmersList.join(", ") : "N/A", // Display all associated swimmers or N/A
                    "Competed YES/NO": competedStatus,
                    "Parent Name": parentName,
                    "Job": job,
                    "Shift": shift,
                    "Points": points,
                    "Met Requirement": metRequirement
                });
            });

            // --- Step 3: Identify and add swimmers who competed but whose parents did NOT volunteer ---
            // These are the rows representing unmet requirements
            for (const meetName in competedSwimmersByMeet) {
                for (const meetDate in competedSwimmersByMeet[meetName]) {
                    for (const swimmerName of competedSwimmersByMeet[meetName][meetDate]) {
                        // If this swimmer-meet combination was NOT covered by a parent who volunteered
                        if (!processedSwimmerMeetCombos.has(`${meetDate}|${meetName}|${swimmerName}`)) {
                            tempReportRows.push({
                                "Meet Date": meetDate,
                                "Meet Name": meetName,
                                "Swimmer Name": swimmerName,
                                "Competed YES/NO": "YES", // Confirmed child competed
                                "Parent Name": "N/A (No Volunteer)", // Explicitly state no parent volunteered for this meet
                                "Job": "N/A",
                                "Shift": "N/A",
                                "Points": "N/A",
                                "Met Requirement": "NO (Child Competed, Parent Not Volunteered)" // Clear failure status
                            });
                        }
                    }
                }
            }

            // Assign the fully processed rows to our global variable
            allReportRows = tempReportRows;

            // Insert the initial table structure into the DOM
            let initialTableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th data-sort-key="Meet Date">Meet Date<span class="sort-arrow"></span></th>
                            <th data-sort-key="Meet Name">Meet Name<span class="sort-arrow"></span></th>
                            <th data-sort-key="Swimmer Name">Swimmer(s)<span class="sort-arrow"></span></th>
                            <th data-sort-key="Competed YES/NO">Competed?<span class="sort-arrow"></span></th>
                            <th data-sort-key="Parent Name">Parent Name<span class="sort-arrow"></span></th>
                            <th data-sort-key="Job">Job<span class="sort-arrow"></span></th>
                            <th data-sort-key="Shift">Shift<span class="sort-arrow"></span></th>
                            <th data-sort-key="Points">Points<span class="sort-arrow"></span></th>
                            <th data-sort-key="Met Requirement">Met Requirement<span class="sort-arrow"></span></th>
                        </tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            `;
            container.innerHTML = initialTableHtml;

            // Initialize features: dropdown filter, sorting, and then apply initial filters/sorts
            populateParentFilterDropdown(parentVolunteers); // Pass the loaded parent data to populate the filter dropdown
            initSorting(); // Set up sorting event listeners

            applyFiltersAndSort(); // This call will perform the initial rendering of the table based on default sort and no filter
        }

        // Add event listener to run the report generation when the HTML document is fully loaded
        document.addEventListener('DOMContentLoaded', generateReport);
    </script>
</body>
</html>
