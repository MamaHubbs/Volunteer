<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volunteer Requirement Report</title>
    <style>
        /* BASE STYLES FROM USER'S WEBSITE */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f8f8f8;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #0156B3;
            font-size: 2em;
            margin-bottom: 10px;
        }

        /* Filter/Dropdown Section - Renamed classes to match provided CSS */
        .dropdown-container {
            text-align: center;
            margin-bottom: 8px;
            font-size: 0.7em;
            position: sticky; /* Makes it stick at the top */
            top: 0;
            background-color: #f8f8f8;
            padding: 10px 0;
            z-index: 1000; /* Ensures it stays above the table header when scrolling */
            border-bottom: 1px solid #ccc;
        }

        .dropdown-box {
            display: inline-block;
            margin: 0 4px;
        }

        label {
            font-weight: bold;
            display: block;
            margin-bottom: 6px;
        }

        select, input[type="text"] {
            padding: 3px 6px;
            font-size: 0.7em;
            border-radius: 4px;
            border: 1px solid #ccc; /* Added border that was missing in user's provided CSS for select/input */
        }

        button {
            padding: 4px 8px;
            font-size: 0.7em;
            border-radius: 4px;
            background-color: #0156B3;
            color: white;
            border: none;
            cursor: pointer;
        }

        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.68em;
            margin-top: 10px;
            /* Removed box-shadow, border-radius as they were not in the new base style */
        }

        th, td {
            padding: 6px 10px;
            border: 1px solid #ccc;
            text-align: left;
            vertical-align: top;
        }

        th {
            background-color: #e5f1ff;
            position: sticky;
            top: 50px; /* Stays below the sticky dropdown-container */
            z-index: 1; /* Stays above table body */
            cursor: pointer;
            white-space: nowrap; /* Prevent header text from wrapping */
        }
        
        /* Sort Arrows - Using the th.sortable::after pseudo-element */
        th.sortable::after {
            content: ' \21C5'; /* Default up-down arrow */
            font-size: 0.68em;
            color: #666;
            margin-left: 5px; /* Added spacing */
        }
        th.sortable.asc::after { /* Specific arrow for ascending sort */
            content: ' \25B2'; /* Up-pointing triangle */
            color: #0156B3; /* Highlight color */
        }
        th.sortable.desc::after { /* Specific arrow for descending sort */
            content: ' \25BC'; /* Down-pointing triangle */
            color: #0156B3; /* Highlight color */
        }

        /* Alternating row colors from user's CSS */
        .row-group-even { /* Note: These classes are not dynamically added by current JS */
            background-color: #ffffff;
        }
        .row-group-odd { /* Note: These classes are not dynamically added by current JS */
            background-color: #f0f0f0;
        }
        /* Keeping basic nth-child for now */
        tbody tr:nth-child(even) { background-color: #fdfdfd; } /* Slightly different from row-group-even */
        tbody tr:nth-child(odd) { background-color: #ffffff; } /* Slightly different from row-group-odd */
        
        tbody tr:hover { background-color: #eaf6ff; } /* Keeping hover from previous version */

        /* Error Message - Renamed class to match user's CSS */
        .error {
            color: red;
            text-align: center;
            margin-top: 20px;
        }

        /* Column Widths - Adjusted to fit 9 columns and content better, while keeping user's style intent */
        th:nth-child(1), td:nth-child(1) { max-width: 90px; width: 6%; }   /* Meet Date */
        th:nth-child(2), td:nth-child(2) { max-width: 160px; width: 12%; } /* Meet Name */
        th:nth-child(3), td:nth-child(3) { max-width: 140px; width: 21%; } /* Swimmer(s) */
        th:nth-child(4), td:nth-child(4) { max-width: 60px; width: 5%; text-align: center; } /* Competed? */
        th:nth-child(5), td:nth-child(5) { max-width: 140px; width: 12%; } /* Parent Name */
        th:nth-child(6), td:nth-child(6) { max-width: 80px; width: 8%; }   /* Job */
        th:nth-child(7), td:nth-child(7) { max-width: 100px; width: 19%; } /* Shift */
        th:nth-child(8), td:nth-child(8) { max-width: 40px; width: 5%; text-align: center; } /* Points */
        th:nth-child(9), td:nth-child(9) { max-width: 110px; width: 12%; } /* Met Requirement */

        /* Cell content overflow from user's CSS */
        td {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Conditional Styling for Competed / Met Requirement - Keeping these specific colors */
        .competed-yes { background-color: #d4edda; }
        .competed-no { background-color: #f8d7da; }
        .met-yes { font-weight: bold; color: #28a745; }
        .met-no { font-weight: bold; color: #dc3545; }
        .met-na { color: #6c757d; font-style: italic; }

        /* Loading message - Adjusted from error-message to a more general class name */
        .loading-message { color: #3498db; font-style: italic; text-align: center; padding: 20px; }
    </style>
</head>
<body>
    <h1>Volunteer Requirement Report</h1>
    <p>This report helps compare swimmers who competed in a meet with parents who volunteered. <br>
       <strong>Rule:</strong> If a family had a swimmer competing in a meet, a parent should have volunteered for that meet.</p>

    <div class="dropdown-container">
        <div class="dropdown-box">
            <label for="parentNameFilterSelect">Parent Name:</label>
            <select id="parentNameFilterSelect">
                <option value="">All Parents</option>
            </select>
        </div>
        <div class="dropdown-box">
            <label for="metRequirementFilterSelect">Met Requirement:</label>
            <select id="metRequirementFilterSelect">
                <option value="">All Statuses</option>
                <option value="YES">Met (YES)</option>
                <option value="NO">Not Met (NO)</option>
                <option value="N/A">N/A</option>
            </select>
        </div>
    </div>

    <div id="report-container" class="loading-message">Loading report data...</div>

    <script>
        // --- IMPORTANT: These URLs are pre-filled based on your previous input ---
        const PARENT_DATA_URL = 'https://raw.githubusercontent.com/MamaHubbs/Volunteer/refs/heads/main/2025_volunteerdata.json';
        const SWIMMER_DATA_URL = 'https://raw.githubusercontent.com/MamaHubbs/Volunteer/refs/heads/main/2025_swimmerdata.json';
        // --- END IMPORTANT ---

        let allReportRows = [];
        let currentSortKey = "Meet Date";
        let currentSortDirection = "asc";
        let currentFilterParentName = "";
        let currentFilterMetRequirement = "";

        function parseDataclipJson(data) {
            if (!data || !Array.isArray(data.fields) || !Array.isArray(data.values)) {
                console.warn("Provided data does not match expected Dataclip JSON format:", data);
                return [];
            }
            const fields = data.fields;
            const values = data.values;
            return values.map(row => {
                const obj = {};
                fields.forEach((field, index) => {
                    obj[field] = row[index];
                });
                return obj;
            });
        }

        async function loadJsonData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} for ${url}`);
                }
                const rawData = await response.json();
                return parseDataclipJson(rawData);
            } catch (error) {
                console.error(`Error loading or parsing data from ${url}:`, error);
                const container = document.getElementById('report-container');
                container.innerHTML = `<p class="error">Failed to load data from ${url}. Please check the URL, network, or JSON format. Error: ${error.message}</p>`;
                throw error;
            }
        }

        function renderTableBody(dataRows) {
            const tbody = document.querySelector('#report-container tbody');
            if (!tbody) return;

            tbody.innerHTML = '';

            if (dataRows.length === 0) {
                tbody.insertAdjacentHTML('beforeend', `<tr><td colspan="9" style="text-align: center; color: #6c757d;">No results found for current filters.</td></tr>`);
                return;
            }

            dataRows.forEach(rowData => {
                const competedClass = rowData["Competed YES/NO"] === "YES" ? "competed-yes" : "competed-no";
                const metClass = rowData["Met Requirement"] === "YES" ? "met-yes" :
                                 (rowData["Met Requirement"].startsWith("NO") ? "met-no" : "met-na");

                const rowHtml = `
                    <tr class="${competedClass}">
                        <td>${rowData["Meet Date"] || "N/A"}</td>
                        <td>${rowData["Meet Name"] || "N/A"}</td>
                        <td>${rowData["Swimmer Name"] || "N/A"}</td>
                        <td>${rowData["Competed YES/NO"] || "N/A"}</td>
                        <td>${rowData["Parent Name"] || "N/A"}</td>
                        <td>${rowData["Job"] || "N/A"}</td>
                        <td>${rowData["Shift"] || "N/A"}</td>
                        <td>${rowData["Points"] || "N/A"}</td>
                        <td class="${metClass}">${rowData["Met Requirement"] || "N/A"}</td>
                    </tr>
                `;
                tbody.insertAdjacentHTML('beforeend', rowHtml);
            });
        }

        function applyFiltersAndSort() {
            let filteredRows = allReportRows;

            // Apply Parent Name filter
            if (currentFilterParentName && currentFilterParentName !== "") {
                const filterParentNames = currentFilterParentName.split('; ').map(name => name.trim());

                filteredRows = filteredRows.filter(row => {
                    const rowParents = row._allParentNamesForFilter || []; // Use the new internal property
                    return filterParentNames.some(filterName => rowParents.includes(filterName));
                });
            }

            // Apply Met Requirement filter
            if (currentFilterMetRequirement && currentFilterMetRequirement !== "") {
                filteredRows = filteredRows.filter(row => {
                    if (currentFilterMetRequirement === "YES") {
                        return row["Met Requirement"] === "YES";
                    } else if (currentFilterMetRequirement === "NO") {
                        return row["Met Requirement"].startsWith("NO");
                    } else if (currentFilterMetRequirement === "N/A") {
                        return row["Met Requirement"].startsWith("N/A");
                    }
                    return false;
                });
            }

            // Apply sort
            filteredRows.sort((a, b) => {
                const valA = a[currentSortKey];
                const valB = b[currentSortKey];

                let comparison = 0;

                if (currentSortKey === "Meet Date") {
                    comparison = new Date(valA) - new Date(valB);
                } else if (currentSortKey === "Points") {
                    comparison = (parseFloat(valA) || 0) - (parseFloat(valB) || 0);
                } else if (currentSortKey === "Competed YES/NO" || currentSortKey === "Met Requirement") {
                    const order = {
                        "YES": 1,
                        "N/A (No Child Competed)": 2,
                        "NO (Child Competed, Parent Not Volunteered)": 3,
                        "N/A": 4
                    };
                    comparison = (order[valA] || 99) - (order[valB] || 99);
                } else {
                    comparison = String(valA).localeCompare(String(valB));
                }

                return currentSortDirection === "asc" ? comparison : -comparison;
            });

            renderTableBody(filteredRows);
        }

        function initSorting() {
            document.querySelectorAll('th[data-sort-key]').forEach(header => {
                // Add the 'sortable' class to headers that can be sorted
                header.classList.add('sortable');

                header.addEventListener('click', () => {
                    const key = header.getAttribute('data-sort-key');
                    if (currentSortKey === key) {
                        currentSortDirection = (currentSortDirection === "asc") ? "desc" : "asc";
                    } else {
                        currentSortKey = key;
                        currentSortDirection = "asc";
                    }

                    // Remove existing sort direction classes from all headers
                    document.querySelectorAll('th[data-sort-key]').forEach(th => th.classList.remove('asc', 'desc'));
                    // Add the correct sort direction class to the currently sorted header
                    header.classList.add(currentSortDirection);

                    applyFiltersAndSort();
                });
                // The sort arrow is handled by CSS ::after pseudo-element based on .sortable, .asc, .desc classes
            });
            // Initial sort applied in generateReport via applyFiltersAndSort
        }

        function populateParentFilterDropdown(parentVolunteersData, swimmersCompetingData) {
            const selectElement = document.getElementById('parentNameFilterSelect');
            const uniqueParents = new Set();

            // Add parents from volunteer data
            parentVolunteersData.forEach(row => {
                if (row.Parent && row.Parent !== "N/A (No Volunteer)") {
                    uniqueParents.add(row.Parent);
                }
            });

            // Add parents associated with competing swimmers (from new column in swimmerData)
            swimmersCompetingData.forEach(row => {
                const parentsString = row["Associated Parents For Swimmer"];
                if (parentsString && parentsString !== "No Parent Linked (for Swimmer)") {
                    // Split the string and add each individual parent name
                    parentsString.split('; ').forEach(parent => uniqueParents.add(parent.trim()));
                }
            });

            const sortedParents = Array.from(uniqueParents).sort();

            selectElement.innerHTML = '<option value="">All Parents</option>';

            sortedParents.forEach(parentName => {
                const option = document.createElement('option');
                option.value = parentName;
                option.textContent = parentName;
                selectElement.appendChild(option);
            });

            selectElement.addEventListener('change', (event) => {
                currentFilterParentName = event.target.value;
                applyFiltersAndSort();
            });
        }

        function initMetRequirementFilter() {
            const selectElement = document.getElementById('metRequirementFilterSelect');
            selectElement.addEventListener('change', (event) => {
                currentFilterMetRequirement = event.target.value;
                applyFiltersAndSort();
            });
        }

        async function generateReport() {
            const container = document.getElementById('report-container');
            container.innerHTML = '<p class="loading-message">Processing data...</p>';

            let swimmersCompeting = [];
            let parentVolunteers = [];

            try {
                swimmersCompeting = await loadJsonData(SWIMMER_DATA_URL);
                parentVolunteers = await loadJsonData(PARENT_DATA_URL);
            } catch (error) {
                return;
            }

            if (!swimmersCompeting.length && !parentVolunteers.length) {
                container.innerHTML = "<p>No data loaded to generate report.</p>";
                return;
            }

            const competedSwimmersByMeet = {}; // Stores {meetName: {meetDate: {swimmerName: "Associated Parents String"}}}
            swimmersCompeting.forEach(row => {
                const meetName = row["Meet Name"];
                const meetDate = row["Meet Date"];
                const swimmerName = row["Swimmer Name"];
                const countResults = row["Count of Events With Results"] || 0;
                const associatedParents = row["Associated Parents For Swimmer"];

                if (meetName && meetDate && swimmerName && countResults > 0) {
                    if (!(meetName in competedSwimmersByMeet)) {
                        competedSwimmersByMeet[meetName] = {};
                    }
                    if (!(meetDate in competedSwimmersByMeet[meetName])) {
                        competedSwimmersByMeet[meetName][meetDate] = {};
                    }
                    competedSwimmersByMeet[meetName][meetDate][swimmerName] = associatedParents; // Store parents for this swimmer
                }
            });

            const tempReportRows = [];
            const processedParentJobCombos = new Set();
            const processedSwimmerMeetCombos = new Set(); // Stores 'date|name|swimmer' combos that had a parent volunteer

            parentVolunteers.forEach(parentRow => {
                const meetDate = parentRow["Meet Date"];
                const meetName = parentRow["Meet Name"];
                const parentName = parentRow.Parent;
                const job = parentRow.Job;
                const shift = parentRow.Shift;
                const points = parentRow.Points;

                const parentJobId = `${meetDate}|${meetName}|${parentName}|${job}|${shift}|${points}`;
                if (processedParentJobCombos.has(parentJobId)) {
                    return;
                }
                processedParentJobCombos.add(parentJobId);

                const associatedSwimmersList = [];
                for (let i = 1; i <= 9; i++) {
                    const swimmerCol = parentRow[`Swimmer ${i}`];
                    if (swimmerCol) {
                        associatedSwimmersList.push(swimmerCol);
                    }
                }

                let competedStatus = "NO";
                for (const swimmer of associatedSwimmersList) {
                    if (meetName in competedSwimmersByMeet &&
                       meetDate in competedSwimmersByMeet[meetName] &&
                       swimmer in competedSwimmersByMeet[meetName][meetDate]) {
                        competedStatus = "YES";
                        processedSwimmerMeetCombos.add(`${meetDate}|${meetName}|${swimmer}`);
                    }
                }

                let metRequirement;
                if (competedStatus === "YES") {
                    metRequirement = "YES";
                } else {
                    metRequirement = "N/A (No Child Competed)";
                }

                const row = {
                    "Meet Date": meetDate,
                    "Meet Name": meetName,
                    "Swimmer Name": associatedSwimmersList.length ? associatedSwimmersList.join(", ") : "N/A",
                    "Competed YES/NO": competedStatus,
                    "Parent Name": parentName, // This is the volunteer parent
                    "Job": job,
                    "Shift": shift,
                    "Points": points,
                    "Met Requirement": metRequirement,
                    // Store the volunteer parent's name for filtering
                    _allParentNamesForFilter: [parentName].filter(name => name !== "N/A (No Volunteer)")
                };
                tempReportRows.push(row);
            });

            for (const meetName in competedSwimmersByMeet) {
                for (const meetDate in competedSwimmersByMeet[meetName]) {
                    for (const swimmerName in competedSwimmersByMeet[meetName][meetDate]) {
                        const swimmerParents = competedSwimmersByMeet[meetName][meetDate][swimmerName];
                        if (!processedSwimmerMeetCombos.has(`${meetDate}|${meetName}|${swimmerName}`)) {
                            const row = {
                                "Meet Date": meetDate,
                                "Meet Name": meetName,
                                "Swimmer Name": swimmerName,
                                "Competed YES/NO": "YES",
                                "Parent Name": swimmerParents, // Display associated parents from swimmer data
                                "Job": "N/A",
                                "Shift": "N/A",
                                "Points": "N/A",
                                "Met Requirement": "NO (Child Competed, Parent Not Volunteered)",
                                // Store the associated swimmer parents for filtering
                                _allParentNamesForFilter: swimmerParents.split('; ').map(name => name.trim()).filter(name => name !== "No Parent Linked (for Swimmer)")
                            };
                            tempReportRows.push(row);
                        }
                    }
                }
            }

            allReportRows = tempReportRows;

            let initialTableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th data-sort-key="Meet Date">Meet Date</th>
                            <th data-sort-key="Meet Name">Meet Name</th>
                            <th data-sort-key="Swimmer Name">Swimmer(s)</th>
                            <th data-sort-key="Competed YES/NO">Competed?</th>
                            <th data-sort-key="Parent Name">Parent Name</th>
                            <th data-sort-key="Job">Job</th>
                            <th data-sort-key="Shift">Shift</th>
                            <th data-sort-key="Points">Points</th>
                            <th data-sort-key="Met Requirement">Met Requirement</th>
                        </tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            `;
            container.innerHTML = initialTableHtml;

            populateParentFilterDropdown(parentVolunteers, swimmersCompeting);
            initMetRequirementFilter();
            initSorting();

            applyFiltersAndSort();
        }

        document.addEventListener('DOMContentLoaded', generateReport);
    </script>
</body>
</html>
